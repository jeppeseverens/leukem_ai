
```{r}
inner_cv_results <- readRDS("../data/out/inner_cv/inner_cv_results.rds")
```

Performance inner folds

```{r}
probability_matrices <- inner_cv_results$probability_matrices
probability_matrices[["Global_ensemble"]] <- list("cv" = inner_cv_results$ensemble_results$cv$global_optimized_ensemble_matrices$matrices,
                                                  "loso" = inner_cv_results$ensemble_results$loso$global_optimized_ensemble_matrices$matrices)
probability_matrices[["OvR_ensemble"]] <- list("cv" = inner_cv_results$ensemble_results$cv$ovr_optimized_ensemble_matrices,
                                                  "loso" = inner_cv_results$ensemble_results$loso$ovr_optimized_ensemble_matrices)

extract_kappa <- function(probability_matrix, model, type){
  inner_folds <- unique(probability_matrix$inner_fold)
  results <- list()
  for (inner_fold in inner_folds){
    subset <- probability_matrix[probability_matrix$inner_fold == inner_fold,]
    truth <- make.names(subset$y)
    outer_fold <- subset$outer_fold[1]
    subset <- subset[, !colnames(subset) %in% c("y", "inner_fold", "outer_fold", "indices", "study"), drop = FALSE]
    
    # Get predictions
    preds <- colnames(subset)[apply(subset, 1, which.max)]
    
    # Clean class labels
    truth <- gsub("Class.", "", truth)
    preds <- gsub("Class.", "", preds)
    
    # Ensure all classes are represented
    all_classes <- unique(c(truth, preds))
    truth <- factor(truth, levels = all_classes)
    preds <- factor(preds, levels = all_classes)
    
    # Calculate confusion matrix and metrics
    cm <- caret::confusionMatrix(preds, truth)
    results[[length(results)+1]] <- data.frame(model,
               type,
               inner_fold,
               outer_fold,
               kappa = cm$overall["Kappa"]
    )
  }
  results <- do.call(rbind, results)
}

inner_results <- list()
models <- names(probability_matrices)
for (model in models){
  types <- names(probability_matrices[[model]])
  for (type in types){
    folds <- names(probability_matrices[[model]][[type]])
    for (fold in folds){
      inner_results[[length(inner_results) + 1]] <- extract_kappa(probability_matrices[[model]][[type]][[fold]], model, type)
    }
  }
}
inner_results <- do.call(rbind, inner_results)
```

```{r}
library(dplyr)
library(ggplot2)

# summarise mean kappa per model and type
summary_df <- inner_results %>%
  group_by(model, type) %>%
  summarise(mean_kappa = mean(kappa, na.rm = TRUE), .groups = "drop")

# plot
ggplot() +
  # barplot for mean kappa
  geom_col(
    data = summary_df,
    aes(x = type, y = mean_kappa, fill = type),
    width = 0.3,
    alpha = 0.7
  ) +
  # points for individual fold kappas
  geom_point(
    data = inner_results,
    aes(x = type, y = kappa),
    size = 2,
    alpha = 0.4,
    color = "black"
  ) +
  facet_wrap(~ model, scales = "free_x") +
  labs(
    x = "Type",
    y = "Kappa",
    title = "Mean Kappa with fold-level values"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  ) + ylim(0,1)

```

```{r}
library(dplyr)
library(ggplot2)

library(dplyr)
library(ggplot2)
library(ggbeeswarm)  # Add this library

# summarise mean kappa per model and type
summary_df <- inner_results %>%
  group_by(model, type) %>%
  summarise(
    mean_kappa = mean(kappa, na.rm = TRUE),
    sd_kappa = sd(kappa, na.rm = TRUE),
    n_folds = n(),
    se_kappa = sd_kappa / sqrt(n_folds),
    .groups = "drop"
  ) 

ggplot() +
  # barplot for mean kappa
  geom_col(
    data = summary_df,
    aes(x = model, y = mean_kappa, fill = model),
    alpha = 0.8,
    position = position_dodge(0.8)
  ) +
  # dots for individual folds with beehive dodge
  geom_beeswarm(
    data = inner_results,
    aes(x = model, y = kappa, fill = model), shape = 21, cex = 1.2, method='hex'
    
  ) +
  # Add value labels on bars
  geom_text(
    data = summary_df,
    aes(x = model, y = 0.05, label = sprintf("%.3f", mean_kappa)),
    position = position_dodge(0.8),
    size = 3,
    fontface = "bold"
  ) +
  facet_wrap(~ type, scales = "free_x") +
  labs(
    x = "Model",
    y = "Kappa",
    title = "Mean Kappa by Model, split by Type",
    subtitle = "Individual points represent CV folds"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40"),
    strip.text = element_text(size = 11, face = "bold"),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "gray80", fill = NA, linewidth = 0.5)
  ) + 
  ylim(0, 1) +
  scale_fill_viridis_d()
```
```{r}
library(ggridges)

ggplot() +
  geom_density_ridges(
    data = inner_results,
    aes(y = model, x = kappa, fill = model),
    alpha = 0.7,
    scale = 1,  # Controls the height of the ridges
    jittered_points = TRUE,
    position = position_points_jitter(width = 0.005, height = 0.00),
    point_shape = '|', point_size = 3, point_alpha = 1
  ) +
  facet_wrap(~ type, scales = "free_x") +
  labs(
    title = "Distribution with Mean Points",
    x = "Kappa",
    y = "Model"
  ) +
  theme_minimal() +
  xlim(0.7, 1) +
  theme(
    legend.position = "none",  # Remove legend since fill is redundant
    strip.text = element_text(size = 11, face = "bold")
  )
```

```{r}
# First, recalculate summary with proper standard errors
summary_df_corrected <- inner_results %>% 
  filter(type == "cv") %>%
  group_by(model, inner_fold) %>%
  summarise(
    mean_kappa = mean(kappa, na.rm = TRUE),
    sd_kappa = sd(kappa, na.rm = TRUE),
    n_obs = n(),  # Number of observations in this group
    se_kappa = sd_kappa / sqrt(n_obs),  # Standard error
    .groups = "drop"
  ) 

# Calculate overall mean performance per fold to sort x-axis
fold_ordering <- summary_df_corrected %>%
  group_by(inner_fold) %>%
  summarise(overall_mean = mean(mean_kappa, na.rm = TRUE)) %>%
  arrange((overall_mean)) %>%
  pull(inner_fold)

# Calculate overall mean performance per model to sort legend/colors
model_ordering <- summary_df_corrected %>%
  group_by(model) %>%
  summarise(overall_mean = mean(mean_kappa, na.rm = TRUE)) %>%
  arrange(desc(overall_mean)) %>%  # Ascending order (lowest at bottom, highest at top)
  pull(model)

summary_df_corrected$model <- factor(
  summary_df_corrected$model, 
  levels = model_ordering
)

# Line plot with sorted axes and models
ggplot() +
  geom_ribbon(
    data = summary_df_corrected,
    aes(x = inner_fold, ymin = mean_kappa - se_kappa, ymax = mean_kappa + se_kappa, fill = model, group = model),
    alpha = 0.1
  ) +
  geom_line(
    data = summary_df_corrected,
    aes(x = inner_fold, y = mean_kappa, color = model, group = model),
    size = 0.8,
    alpha = 0.65
  ) +
  geom_point(
    data = summary_df_corrected,
    aes(x = inner_fold, y = mean_kappa, color = model),
    size = 2,
    alpha = 0.8
  ) +
  labs(
    title = "Kappa Performance Across Folds with Standard Error",
    x = "Inner Fold",
    y = "Kappa",
    subtitle = "Ribbons show ±1 standard error around the mean"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40")
  ) +
  # Ensure legend order matches the factor levels
  guides(
    color = guide_legend(reverse = TRUE),  # Reverse legend to match plot order
    fill = guide_legend(reverse = TRUE)
  )

# First, recalculate summary with proper standard errors
summary_df_corrected <- inner_results %>% 
  filter(type == "loso") %>%
  group_by(model, inner_fold) %>%
  summarise(
    mean_kappa = mean(kappa, na.rm = TRUE),
    sd_kappa = sd(kappa, na.rm = TRUE),
    n_obs = n(),  # Number of observations in this group
    se_kappa = sd_kappa / sqrt(n_obs),  # Standard error
    .groups = "drop"
  ) 

# Calculate overall mean performance per fold to sort x-axis
fold_ordering <- summary_df_corrected %>%
  group_by(inner_fold) %>%
  summarise(overall_mean = mean(mean_kappa, na.rm = TRUE)) %>%
  arrange((overall_mean)) %>%
  pull(inner_fold)

# Calculate overall mean performance per model to sort legend/colors
model_ordering <- summary_df_corrected %>%
  group_by(model) %>%
  summarise(overall_mean = mean(mean_kappa, na.rm = TRUE)) %>%
  arrange(desc(overall_mean)) %>%  # Ascending order (lowest at bottom, highest at top)
  pull(model)

# Reorder both factors
summary_df_corrected$inner_fold <- factor(
  summary_df_corrected$inner_fold, 
  levels = fold_ordering
)

summary_df_corrected$model <- factor(
  summary_df_corrected$model, 
  levels = model_ordering
)

# Line plot with sorted axes and models
ggplot() +
  geom_ribbon(
    data = summary_df_corrected,
    aes(x = inner_fold, ymin = mean_kappa - se_kappa, ymax = mean_kappa + se_kappa, fill = model, group = model),
    alpha = 0.1
  ) +
  geom_line(
    data = summary_df_corrected,
    aes(x = inner_fold, y = mean_kappa, color = model, group = model),
    size = 0.8,
    alpha = 0.65
  ) +
  geom_point(
    data = summary_df_corrected,
    aes(x = inner_fold, y = mean_kappa, color = model),
    size = 2,
    alpha = 0.8
  ) +
  labs(
    title = "Kappa Performance Across Folds with Standard Error",
    x = "Inner Fold",
    y = "Kappa",
    subtitle = "Ribbons show ±1 standard error around the mean"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40")
  ) +
  # Ensure legend order matches the factor levels
  guides(
    color = guide_legend(reverse = TRUE),  # Reverse legend to match plot order
    fill = guide_legend(reverse = TRUE)
  )
```
```{r}
library(ggridges)
ggplot(inner_results %>% filter(type == "cv"), 
       aes(x = kappa, y = inner_fold, fill = inner_fold)) +
  geom_density_ridges(alpha = 0.7, jittered_points = TRUE,
    position = position_points_jitter(width = 0.005, height = 0.00),
    point_shape = '|', point_size = 3, point_alpha = 0.6) +
  #facet_wrap(~ model) +
  labs(title = "Density Distribution of Kappa Values") +
  theme_minimal() + xlim(0.65,1)

ggplot(inner_results %>% filter(type == "loso"), 
       aes(x = kappa, y = inner_fold, fill = inner_fold)) +
  geom_density_ridges(alpha = 0.7, jittered_points = TRUE,
    position = position_points_jitter(width = 0.005, height = 0.00),
    point_shape = '|', point_size = 3, point_alpha = 0.6) +
  #facet_wrap(~ model) +
  labs(title = "Density Distribution of Kappa Values") +
  theme_minimal() + xlim(0.65,1)
```


